# Hand-coded Parser

A simple recursive-descend  Parser in pure Java

## Build  

### Requirements

- Java 11
- Maven

### IntelliJ Configuratiom

This project is provided with a set of *IntelliJ Configurations:* 

> To run it just import it as a *Maven project* and click *Run*

### Maven Build

Alternatively you can compile manually typing: 

> mvn package

The *jar* file will be placed under the *target/* directory.  

## Structure

The software is composed of two parts:  
- Lexer
- Parser

The lexer used in this software is fully described at this [link](https://gitlab.com/compilatori-a.a.-2020_21/hand-coded-lexer-es1_hcl/crisci-cuccurullo_es1_hcl). Some small modification have been required to make it suitable for the grammar recognized by the parser. 
More specifically:
- the tokens *INT* and *FLOAT* have been collapsed into a unique *NUMBER* token;
- the *OP* tokens recognized are the relational operators only;
- the only *separator* token recognized is now the *;  (S_COLON)*.

In the following sections the structure of the *parser* will be described.

### Grammar

The **Grammar** the parser recognize is the following:

> Progam -> Stmt Program2   
> Program2 -> ; Stmt Program2  
> Program2 -> ''  
> Stmt -> if Expr then Stmt else Stmt   
> Stmt -> id assign Expr  
> Stmt -> do Stmt while Expr  
> Expr -> id Expr2
> Expr -> num Expr2  
> Expr2 -> relop Expr  
> Expr2 -> ''


### Class Structure

The `Parser` class takes a `Lexer` object in input and exposes a single `boolean parse()` method, which returns `true` if the input text file can be generated by the *grammar* and all the file has been  analyzed, false otherwise.  
The `parse` method maintains a buffer of the token recognized by the `lexer` during the parsing phase and a pointer to the current token that is being analyzed.

For each nonterminal, a method `boolean productionNONTERMINAL_NAME()` is defined. It returns `true` if the token sequence read matches a production of that nonterminal. Because of the recursive-descend nature of this parser, backtracking could be necessary when an incorrect production is chosen: for this case, each method maintains a `int startingPos` variable pointing to the first token to analyze and, when backtracking occours, it sets `pointer` to `startingPos` and tries another production.  

If no produciton matches the token sequence, the method resets `pointer` to `startingPos` and returns `false`.  

## Authors
- *Luigi Crisci*
- *Alessio Cuccurullo*


